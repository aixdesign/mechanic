<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <title>Mechanic</title>
    <style type="text/css">
      html,
      body {
        height: 100vh;
      }
      body {
        align-items: center;
        background-color: #fafbfc;
        color: #172b4d;
        display: flex;
        flex-direction: column;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
          "Segoe UI Symbol";
        font-size: 15px;
        justify-content: center;
        letter-spacing: -0.005em;
        margin: 0;
        padding: 0;
        text-decoration-skip: ink;
        text-rendering: optimizeLegibility;
        -ms-overflow-style: -ms-autohiding-scrollbar;
        -moz-font-feature-settings: "liga" on;
        -moz-osx-font-smoothing: grayscale;
        -webkit-font-smoothing: antialiased;
      }
      h1 {
        font-weight: 300;
        margin-bottom: 0.66em;
        margin-top: 0;
      }
      p {
        color: #6c798f;
      }
      .container {
        margin-top: -4vh;
        padding-left: 1em;
        padding-right: 1em;
        text-align: center;
      }

      .logo {
        font-weight: 800;
        font-size: 60px;
        letter-spacing: -0em;
        max-width: 70vw;
      }

      .logo textPath {
        dominant-baseline: middle;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- <svg
        class="logo"
        viewBox="0 0 400 130"
        width="400">
          <g>
            <ellipse
              cx={leftCx}
              cy={backRadius}
              rx={backRadius / 2}
              ry={backRadius / 2}
              strokeWidth={backRadius}
              stroke="var(--orange)"
              fill="none"
            />
            <ellipse
              cx={rightCx}
              cy={backRadius}
              rx={backRadius / 2}
              ry={backRadius / 2}
              strokeWidth={backRadius}
              stroke="var(--orange)"
              fill="none"
            />
            <ellipse
              cx={rightCx}
              cy={backRadius}
              rx={backRadius / 2}
              ry={backRadius / 2}
              strokeWidth={backRadius}
              stroke="var(--blue)"
              fill="none"
              strokeDasharray={Math.PI * (backRadius / 2)}
              strokeDashoffset={Math.PI * (backRadius * 0.75)}>
              <animate
                id="right1"
                attributeName="stroke-dashoffset"
                from={Math.PI * (backRadius * 0.75)}
                to={Math.PI * (backRadius * 0.25)}
                begin="top1.end"
                dur={`${backRoundDur}s`}
                fill="freeze"
              />
              <animate
                id="right2"
                attributeName="stroke-dashoffset"
                from={Math.PI * (backRadius * 1.25)}
                to={Math.PI * (backRadius * 0.75)}
                begin="top3.end"
                dur={`${backRoundDur}s`}
                fill="freeze"
              />
            </ellipse>
            <ellipse
              cx={leftCx}
              cy={backRadius}
              rx={backRadius / 2}
              ry={backRadius / 2}
              strokeWidth={backRadius}
              stroke="var(--blue)"
              fill="none"
              strokeDasharray={Math.PI * (backRadius / 2)}
              strokeDashoffset={Math.PI * (backRadius * 1.25)}>
              <animate
                id="left1"
                attributeName="stroke-dashoffset"
                from={Math.PI * (backRadius * 1.25)}
                to={Math.PI * (backRadius * 0.75)}
                begin="bot1.end"
                dur={`${backRoundDur}s`}
                fill="freeze"
              />
              <animate
                id="left2"
                attributeName="stroke-dashoffset"
                from={Math.PI * (backRadius * 0.75)}
                to={Math.PI * (backRadius * 0.25)}
                begin="bot3.end"
                dur={`${backRoundDur}s`}
                fill="freeze"
              />
            </ellipse>
            {/* This is a fake element for the start of the SVG animation */}
            <ellipse
              cx={leftCx}
              cy={backRadius}
              rx={backRadius / 2}
              ry={backRadius / 2}
              strokeWidth={backRadius}
              stroke="var(--blue)"
              fill="none"
              strokeDasharray={Math.PI * (backRadius / 2)}
              strokeDashoffset={Math.PI * (backRadius * 0.75)}>
              <animate
                attributeName="stroke-dashoffset"
                from={Math.PI * (backRadius * 0.75)}
                to={Math.PI * (backRadius * 0.25)}
                begin="fakeBot.end"
                dur={`${backRoundDur}s`}
                fill="freeze"
              />
            </ellipse>
            <rect
              x={backRadius}
              y={0}
              width={backStraightLength}
              height={backRadius * 2}
              stroke="none"
              fill="var(--orange)"
            />
            <rect
              x={backRadius}
              y="0"
              width={0}
              height={backRadius}
              fill="var(--blue)">
              <animate
                id="top1"
                attributeName="width"
                from={0}
                to={backStraightLength}
                begin="0.1s;left1.end"
                dur={`${backStraightDur}s`}
                fill="freeze"
              />
              <animate
                id="top2"
                attributeName="x"
                from={backRadius}
                to={trackWidth + fontHeight / 2}
                begin={`${txtCycle / 2 + 0.15}s;left2.end`}
                dur={`${backStraightDur}s`}
              />
              )}
              <animate
                id="top3"
                attributeName="width"
                from={backStraightLength}
                to={0}
                begin="top2.begin"
                dur={`${backStraightDur}s`}
                fill="freeze"
              />
            </rect>
            <rect
              x={backRadius}
              y={backRadius}
              width={0}
              height={backRadius}
              fill="var(--blue)">
              <animate
                id="bot1"
                attributeName="x"
                from={backRadius + backStraightLength}
                to={backRadius}
                begin={`right1.end`}
                dur={`${backStraightDur}s`}
              />
              <animate
                id="bot2"
                attributeName="width"
                from={0}
                to={backStraightLength}
                begin={`right1.end`}
                dur={`${backStraightDur}s`}
                fill="freeze"
              />
              <animate
                id="bot3"
                attributeName="width"
                from={backStraightLength}
                to={0}
                begin="right2.end"
                dur={`${backStraightDur}s`}
                fill="freeze"
              />
            </rect>
            {/* This is a fake element for the start of the SVG animation */}
            <rect
              x={backRadius}
              y={backRadius}
              width={backStraightLength}
              height={backRadius}
              fill="var(--blue)">
              <animate
                id="fakeBot"
                attributeName="width"
                from={backStraightLength}
                to={0}
                begin="0.1s"
                dur={`${backStraightDur}s`}
                fill="freeze"
              />
            </rect>
          </g>
        <g>
          <path
            id="track1"
            fill="none"
            stroke={showTrack ? "black" : "none"}
            transform={`translate(${fontHeight},${fontHeight})`}
            d={`M ${trackRadius},0 h ${
              trackWidth - 2 * trackRadius
            } a ${trackRadius} ${trackRadius} 0 0 1 0 ${
              2 * trackRadius
            } H ${trackRadius} a ${trackRadius} ${trackRadius} 0 0 1 0 -${
              2 * trackRadius
            }`}
          />
          <path
            id="track2"
            fill="none"
            stroke={showTrack ? "black" : "none"}
            transform={`translate(${fontHeight},${fontHeight})`}
            d={`M ${trackWidth - trackRadius},${
              trackRadius * 2
            } H ${trackRadius} a ${trackRadius} ${trackRadius} 0 0 1 0 -${
              2 * trackRadius
            } h ${
              trackWidth - 2 * trackRadius
            } a ${trackRadius} ${trackRadius} 0 0 1 0 ${2 * trackRadius}`}
          />
        </g>
  
        {showText && (
          <g>
            <text fill="white">
              <textPath href="#track1">
                MECHANIC
                <animate
                  id="txt1"
                  attributeName="startOffset"
                  from={0}
                  to={trackLength}
                  begin="0s"
                  dur={`${txtCycle}s`}
                  repeatCount="indefinite"
                />
              </textPath>
              <textPath href="#track2">
                MECHANIC
                <animate
                  attributeName="startOffset"
                  from={-trackLength / 2}
                  to={trackLength / 2}
                  begin="txt1.begin"
                  dur={`${txtCycle}s`}
                  repeatCount="indefinite"
                />
              </textPath>
              <textPath href="#track2">
                MECHANIC
                <animate
                  attributeName="startOffset"
                  from={0}
                  to={trackLength}
                  begin="txt1.begin"
                  dur={`${txtCycle}s`}
                  repeatCount="indefinite"
                />
              </textPath>
              <textPath href="#track1">
                MECHANIC
                <animate
                  attributeName="startOffset"
                  from={-trackLength / 2}
                  to={trackLength / 2}
                  begin="txt1.begin"
                  dur={`${txtCycle}s`}
                  repeatCount="indefinite"
                />
              </textPath>
            </text>
          </g>
        )}
      </svg> -->

      <h1>Mechanic is <span id="status">loading...</span></h1>
      <p>This page will reload when the server is ready</p>
    </div>
    <script>
      const statusEl = document.querySelector("#status");
      let ready = false;

      function onReady() {
        statusEl.innerHTML = "ready!";
        ready = true;
        location.reload(true);
      }

      function checkAndSetStatus() {
        let cancelled = false;
        fetch("/", { headers: { Accept: "application/json" } })
          .then((result) => result.json())
          .catch((error) => {
            // We can get back an error "Cannot parse JSON" when a HTML
            // response is returned, so we assume the server is ready
            onReady();
          })
          .then(({ loading, status } = {}) => {
            if (!loading) {
              onReady();
              return;
            }
            if (cancelled) {
              return;
            }
            switch (status) {
              case "init-keystone": {
                statusEl.innerHTML = "initialising...";
                break;
              }
              case "db-connect": {
                statusEl.innerHTML = "connecting to the database...";
                break;
              }
              case "start-server":
              default: {
                statusEl.innerHTML = "loading...";
                break;
              }
            }
          });
        return () => {
          cancelled = true;
        };
      }

      let cancelLastCall = checkAndSetStatus();
      const interval = setInterval(() => {
        cancelLastCall();
        if (ready) {
          clearInterval(interval);
          return;
        }
        cancelLastCall = checkAndSetStatus();
      }, 500);
    </script>
  </body>
</html>
